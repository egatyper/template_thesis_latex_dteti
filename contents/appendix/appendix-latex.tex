\chapter*{LAMPIRAN}

\section{Spesifikasi API Sistem RAG}

%-----------------------------------------------------
% Endpoint 1: Process File Uploaded
%-----------------------------------------------------
%=====================================================
% Endpoint 1: Process File Uploaded
%=====================================================
\subsection{API: Process File Uploaded}

\begin{longtable}{p{0.2\textwidth}p{0.8\textwidth}}
	\caption{Spesifikasi API Process File Uploaded} \label{api:process-file}                                                         \\
	\hline
	\textbf{Properti} & \textbf{Keterangan}                                                                                          \\
	\hline \hline
	\endfirsthead % Header untuk halaman pertama
	\caption[]{Spesifikasi API Process File Uploaded (Lanjutan)}                                                                     \\
	\hline
	\textbf{Properti} & \textbf{Keterangan}                                                                                          \\
	\hline \hline
	\endhead % Header untuk halaman selanjutnya
	HTTP Method       & \texttt{POST}                                                                                                \\
	URL Path          & \texttt{/api/v1/extraction/extract}                                                                          \\
	Deskripsi         & Mengekstrak konten dari file dokumen (docx, html, pdf) untuk diproses dan disimpan ke dalam basis data graf. \\
	\hline
\end{longtable}

\begin{longtable}{p{0.25\textwidth} p{0.15\textwidth} p{0.6\textwidth}}
	\caption{Spesifikasi Parameter API Process File Uploaded} \label{api:param-process-file}                           \\
	\hline
	\textbf{Parameter}  & \textbf{Tipe}    & \textbf{Deskripsi}                                                        \\
	\hline \hline
	\endfirsthead
	\caption[]{Spesifikasi Parameter API Process File Uploaded (Lanjutan)}                                             \\
	\hline
	\textbf{Parameter}  & \textbf{Tipe}    & \textbf{Deskripsi}                                                        \\
	\hline \hline
	\endhead
	\texttt{file\_path} & \texttt{string}  & Path menuju file yang akan diproses.                                      \\
	\texttt{file\_type} & \texttt{string}  & Pilihan tipe file: \texttt{'docx'}, \texttt{'html'}, atau \texttt{'pdf'}. \\
	\texttt{split}      & \texttt{boolean} & Jika \texttt{true}, dokumen akan dipecah menjadi beberapa bagian.         \\
	\hline
\end{longtable}

\subsection{API: Get Answer from Knowledge Graph}

\begin{longtable}{p{0.2\textwidth}p{0.8\textwidth}}
	\caption{Spesifikasi API Get Answer from KG} \label{api:get-answer-kg}                                                   \\
	\hline
	\textbf{Properti} & \textbf{Keterangan}                                                                                  \\
	\hline \hline
	\endfirsthead
	\caption[]{Spesifikasi API Get Answer from KG (Lanjutan)}                                                                \\
	\hline
	\textbf{Properti} & \textbf{Keterangan}                                                                                  \\
	\hline \hline
	\endhead
	HTTP Method       & \texttt{POST}                                                                                        \\
	URL Path          & \texttt{/api/v1/retrieval/get-answer}                                                                \\
	Deskripsi         & Menerima kueri pengguna dan mengambil jawaban berdasarkan penelusuran pada \textit{Knowledge Graph}. \\
	\hline
\end{longtable}

\begin{longtable}{p{0.25\textwidth} p{0.15\textwidth} p{0.6\textwidth}}
	\caption{Spesifikasi Parameter API Get Answer from KG} \label{api:param-get-answer-kg}                                                                         \\
	\hline
	\textbf{Parameter}        & \textbf{Tipe}    & \textbf{Deskripsi}                                                                                              \\
	\hline \hline
	\endfirsthead
	\caption[]{Spesifikasi Parameter API Get Answer from KG (Lanjutan)}                                                                                            \\
	\hline
	\textbf{Parameter}        & \textbf{Tipe}    & \textbf{Deskripsi}                                                                                              \\
	\hline \hline
	\endhead
	\texttt{query}            & \texttt{string}  & Pertanyaan dari pengguna.                                                                                       \\
	\texttt{graph\_traversal} & \texttt{string}  & Metode penelusuran graf. Pilihan: \texttt{'neighbor\_expansion'}, \texttt{'n-shortest\_path'}, \texttt{'auto'}. \\
	\texttt{search\_method}   & \texttt{string}  & Metode pencarian entitas awal. Pilihan: \texttt{'vector'}, \texttt{'auto'}.                                     \\
	\texttt{max\_hop}         & \texttt{integer} & (Opsional) Lompatan maksimal untuk pencarian berbasis jalur. Default: 10.                                       \\
	\texttt{limit}            & \texttt{integer} & (Opsional) Batas total entitas yang diambil. Default: 50.                                                       \\
	\texttt{top\_k}           & \texttt{integer} & (Opsional) Jumlah entitas teratas yang dicari. Default: 3.                                                      \\
	\hline
\end{longtable}


%=====================================================
% Endpoint 3: Generate Evaluation Dataset
%=====================================================
\subsection{API: Generate Evaluation Dataset}

\begin{longtable}{p{0.2\textwidth}p{0.8\textwidth}}
	\caption{Spesifikasi API Generate Evaluation Dataset} \label{api:gen-eval}                                                   \\
	\hline
	\textbf{Properti} & \textbf{Keterangan}                                                                                      \\
	\hline \hline
	\endfirsthead
	\caption[]{Spesifikasi API Generate Evaluation Dataset (Lanjutan)}                                                           \\
	\hline
	\textbf{Properti} & \textbf{Keterangan}                                                                                      \\
	\hline \hline
	\endhead
	HTTP Method       & \texttt{POST}                                                                                            \\
	URL Path          & \texttt{/api/v1/evaluation/generate-evaluation-dataset}                                                  \\
	Deskripsi         & Menghasilkan pasangan tanya-jawab (dataset evaluasi) dari potongan teks (\textit{chunks}) yang spesifik. \\
	\hline
\end{longtable}

\begin{longtable}{p{0.25\textwidth} p{0.15\textwidth} p{0.6\textwidth}}
	\caption{Spesifikasi Parameter API Generate Evaluation Dataset} \label{api:param-gen-eval}                            \\
	\hline
	\textbf{Parameter}  & \textbf{Tipe}  & \textbf{Deskripsi}                                                             \\
	\hline \hline
	\endfirsthead
	\caption[]{Spesifikasi Parameter API Generate Evaluation Dataset (Lanjutan)}                                          \\
	\hline
	\textbf{Parameter}  & \textbf{Tipe}  & \textbf{Deskripsi}                                                             \\
	\hline \hline
	\endhead
	\texttt{chunk\_ids} & \texttt{array} & Daftar ID unik dari potongan teks yang akan dijadikan dasar pembuatan dataset. \\
	\hline
\end{longtable}


%=====================================================
% Endpoint 4: Add Document to Vector DB
%=====================================================
\subsection{API: Add Document to Vector DB}

\begin{longtable}{p{0.2\textwidth}p{0.8\textwidth}}
	\caption{Spesifikasi API Add Document to Vector DB} \label{api:add-vector}                                                          \\
	\hline
	\textbf{Properti} & \textbf{Keterangan}                                                                                             \\
	\hline \hline
	\endfirsthead
	\caption[]{Spesifikasi API Add Document to Vector DB (Lanjutan)}                                                                    \\
	\hline
	\textbf{Properti} & \textbf{Keterangan}                                                                                             \\
	\hline \hline
	\endhead
	HTTP Method       & \texttt{POST}                                                                                                   \\
	URL Path          & \texttt{/api/v1/extraction/extract-rag-vector}                                                                  \\
	Deskripsi         & Memproses file dan menyimpannya sebagai \textit{embedding} ke dalam \textit{vector database} (untuk Naive RAG). \\
	\hline
\end{longtable}

\begin{longtable}{p{0.25\textwidth} p{0.15\textwidth} p{0.6\textwidth}}
	\caption{Spesifikasi Parameter API Add Document to Vector DB} \label{api:param-add-vector}                        \\
	\hline
	\textbf{Parameter}  & \textbf{Tipe}   & \textbf{Deskripsi}                                                        \\
	\hline \hline
	\endfirsthead
	\caption[]{Spesifikasi Parameter API Add Document to Vector DB (Lanjutan)}                                        \\
	\hline
	\textbf{Parameter}  & \textbf{Tipe}   & \textbf{Deskripsi}                                                        \\
	\hline \hline
	\endhead
	\texttt{file\_path} & \texttt{string} & Path menuju file yang akan diproses.                                      \\
	\texttt{file\_type} & \texttt{string} & Pilihan tipe file: \texttt{'docx'}, \texttt{'html'}, atau \texttt{'pdf'}. \\
	\hline
\end{longtable}


%=====================================================
% Endpoint 5: Get Answer from Vector DB (Naive RAG)
%=====================================================
\subsection{API: Get Answer from Vector DB (Naive RAG)}

\begin{longtable}{p{0.2\textwidth}p{0.8\textwidth}}
	\caption{Spesifikasi API Get Answer from Vector DB} \label{api:get-answer-vector}                         \\
	\hline
	\textbf{Properti} & \textbf{Keterangan}                                                                   \\
	\hline \hline
	\endfirsthead
	\caption[]{Spesifikasi API Get Answer from Vector DB (Lanjutan)}                                          \\
	\hline
	\textbf{Properti} & \textbf{Keterangan}                                                                   \\
	\hline \hline
	\endhead
	HTTP Method       & \texttt{POST}                                                                         \\
	URL Path          & \texttt{/api/v1/retrieval/get-answer-vector-rag}                                      \\
	Deskripsi         & Menerima kueri dan mengambil jawaban menggunakan metode Naive RAG (pencarian vektor). \\
	\hline
\end{longtable}

\begin{longtable}{p{0.25\textwidth} p{0.15\textwidth} p{0.6\textwidth}}
	\caption{Spesifikasi Parameter API Get Answer from Vector DB} \label{api:param-get-answer-vector}                                          \\
	\hline
	\textbf{Parameter} & \textbf{Tipe}    & \textbf{Deskripsi}                                                                                 \\
	\hline \hline
	\endfirsthead
	\caption[]{Spesifikasi Parameter API Get Answer from Vector DB (Lanjutan)}                                                                 \\
	\hline
	\textbf{Parameter} & \textbf{Tipe}    & \textbf{Deskripsi}                                                                                 \\
	\hline \hline
	\endhead
	\texttt{query}     & \texttt{string}  & Pertanyaan dari pengguna.                                                                          \\
	\texttt{top\_k}    & \texttt{integer} & (Opsional) Jumlah potongan dokumen teratas yang relevan untuk diambil sebagai konteks. Default: 5. \\
	\hline
\end{longtable}

\vspace{3cm}
\section{Prompt}
\subsection{Prompt untuk Ekstraksi Entitas dan Relasi}
\begin{lstlisting}[numbers=none]
"""
INSTRUKSI:
Anda adalah sebuah pipeline ekstraksi Knowledge Graph untuk domain kesehatan mental. Dari DOKUMEN yang diberikan, ekstrak semua entitas penting dan relasi di antara mereka. Patuhi struktur JSON dan daftar tipe yang telah ditentukan dengan ketat.

LANGKAH-LANGKAH:
1.  **Ekstrak Entitas**: Identifikasi entitas, klasifikasikan tipenya, dan berikan deskripsi yang dapat berupa potongan dari teks asli. Deskripsi dapat meliuti nomor telepon, alamat, atau informasi penting dari entitas. 
2.  **Ekstrak Relasi**: Identifikasi hubungan langsung antar entitas tersebut. `name` relasi harus berupa frasa kerja dari teks, dan `type` adalah kategorisasi formalnya.

---

### **Sistem Tipe (Ontologi)**

**A. Tipe Entitas yang Diizinkan:**
* **Gangguan & Kondisi**: `Gangguan_Mental`, `Gejala`, `Kondisi_Medis_Terkait`
* **Intervensi & Perawatan**: `Terapi_Psikologis`, `Obat_Medis`, `Layanan_Kesehatan`, `Aktivitas_Kesejahteraan`, `Penyedia_Layanan`
* **Aktor & Pemangku Kepentingan**: `Profesional_Kesehatan`, `Organisasi`, `Individu`
* **Faktor & Konteks**: `Faktor_Risiko`, `Faktor_Pelindung`, `Dokumen_Hukum_Kebijakan`, `Lokasi`
* **Data & Konsep**: `Data_Statistik`, `Konsep_Abstrak`
* **Jaring Pengaman**: `Lainnya` (Gunakan untuk entitas penting yang tidak cocok dengan kategori lain)

**B. Tipe Relasi yang Diizinkan:**
* **Sebab-Akibat**: `Menyebabkan`, `Berkontribusi_Pada`, `Mengurangi_Risiko`, `Merupakan_Gejala_Dari`
* **Intervensi**: `Mendiagnosis`, `Menangani`, `Meresepkan`, `Menawarkan_Layanan`
* **Hierarki & Keanggotaan**: `Adalah_Jenis_Dari`, `Bekerja_Di`, `Berlokasi_Di`, `Bagian_Dari`  
* **Deskriptif**: `Memiliki_Atribut`, `Didasarkan_Pada`, `Direkomendasikan_Untuk`
* **Jaring Pengaman**: `Terkait_Dengan` (Gunakan untuk hubungan yang jelas tapi tidak cocok kategori lain)

---

### **Struktur Output JSON**
{
"entities": [
    { 
    "name": "nama_entitas",
    "type": "tipe_entitas_dari_daftar_di_atas",
    "description": "penjelasan berisi informasi penting dari entitas, dapat berupa kutipan asli dari dokumen atau ringkasannya"
    }
],
"relations": [
    {
    "source_entity": "nama_entitas_sumber",
    "target_entity": "nama_entitas_target",
    "name": "frasa_kerja_dari_dokumen",
    "type": "tipe_relasi_dari_daftar_di_atas"
    }
]
}

---

### **CONTOH EKSEKUSI**

**DOKUMEN:**
Kesehatan Jiwa adalah kondisi dimana seorang individu dapat berkembang secara fisik, mental, spiritual, dan sosial. K
arakteristik gangguan jiwa secara umum yaitu kombinasi pikiran yang abnormal, emosi, dan persepsi. 
Faktor psikologis seperti trauma yang mengakibatkan stres dan faktor biologis seperti genetik merupakan faktor yang berkontribusi terhadap terjadinya gangguan jiwa. 
Sebesar 50% gangguan jiwa berawal pada usia 14 tahun.

Layanan Psikologi UGM dan Fakultas

Klinik GMC (Mental Health Support)
Psikolog: +62 813-2620-0342
GMC: +62 851-0047-3123

Layanan Psikologi Fakultas (hanya untuk sivitas fakultas yang bersangkutan)
Biologi: form registrasi
Ekonomika dan Bisnis: Telp: +62 811-2843-884 atau isi Form Registrasi melalui Portal SINTESIS di menu Layanan Konsultasi.

**JSON_OUTPUT:**
{
"entities": [
    {
    "name": "Kesehatan Jiwa",
    "type": "Konsep_Abstrak",
    "description": "kondisi dimana seorang individu dapat berkembang secara fisik, mental, spiritual, dan sosial."
    },
    {
    "name": "Gangguan Jiwa",
    "type": "Gangguan_Mental",
    "description": "Sebuah kondisi yang memiliki karakteristik seperti kombinasi pikiran abnormal, dan dipengaruhi oleh faktor psikologis serta biologis."
    },
    {
    "name": "Karakteristik Gangguan Jiwa",
    "type": "Karakteristik",
    "description": "kombinasi pikiran yang abnormal, emosi, dan persepsi."
    },
    {
    "name": "Faktor Psikologis",
    "type": "Faktor_Risiko",
    "description": "Faktor yang dapat mengakibatkan stres, contohnya trauma."
    },
    {
    "name": "Faktor Biologis",
    "type": "Faktor_Risiko",
    "description": "Faktor yang berkontribusi pada gangguan jiwa, contohnya genetik."
    },
    {
    "name": "Stres",
    "type": "Gejala",
    "description": "Sebuah kondisi yang diakibatkan oleh faktor psikologis seperti trauma."
    },
    {
    "name": "Statistik Onset Gangguan Jiwa",
    "type": "Data_Statistik",
    "description": "Sebesar 50% gangguan jiwa berawal pada usia 14 tahun."
    },
    {
    "name": "Layanan Kesehatan Mental Rumah Sakit Akademik UGM",
    "type": "Penyedia_Layanan",
    "description": "Layanan kesehatan mental yang disediakan oleh Rumah Sakit Akademik (RSA) UGM. Kontak dapat dilakukan melalui telepon di +62 811-2548-118."
    },
    {
    "name": "Klinik GMC - Mental Health Support",
    "type": "Penyedia_Layanan",
    "description": "Layanan dukungan kesehatan mental dari Klinik GMC. Kontak dapat ditujukan ke Psikolog di +62 813-2620-0342 atau ke nomor umum GMC di +62 851-0047-3123."
    },
    {
    "name": "Layanan Psikologi Fakultas Biologi",
    "type": "Penyedia_Layanan",
    "description": "Layanan psikologi khusus untuk sivitas Fakultas Biologi UGM. Pendaftaran dilakukan dengan mengisi form registrasi yang tersedia."
    },
    {
    "name": "Layanan Konsultasi Fakultas Ekonomika dan Bisnis",
    "type": "Penyedia_Layanan",
    "description": "Layanan konsultasi khusus untuk sivitas Fakultas Ekonomika dan Bisnis UGM. Pendaftaran dapat dilakukan melalui telepon di +62 811-2843-884 atau dengan mengisi Form Registrasi via Portal SINTESIS."
    }
],
"relations": [
    {
    "source_entity": "Gangguan Jiwa",
    "target_entity": "Karakteristik Gangguan Jiwa",
    "name": "memiliki karakteristik",
    "type": "Memiliki_Atribut"
    },
    {
    "source_entity": "Faktor Psikologis",
    "target_entity": "Stres",
    "name": "mengakibatkan",
    "type": "Menyebabkan"
    },
    {
    "source_entity": "Faktor Psikologis",
    "target_entity": "Gangguan Jiwa",
    "name": "berkontribusi terhadap",
    "type": "Berkontribusi_Pada"
    },
    {
    "source_entity": "Faktor Biologis",
    "target_entity": "Gangguan Jiwa",
    "name": "berkontribusi terhadap",
    "type": "Berkontribusi_Pada"
    },
    {
    "source_entity": "Gangguan Jiwa",
    "target_entity": "Statistik Onset Gangguan Jiwa",
    "name": "memiliki data onset",
    "type": "Memiliki_Atribut"
    },
    {
    "sumber": "Klinik GMC - Mental Health Support",
    "target": "Layanan Kesehatan Mental Universitas Gadjah Mada",
    "tipe": "Bagian_Dari"
    },
    {
    "sumber": "Layanan Psikologi Fakultas Biologi",
    "target": "Layanan Kesehatan Mental Universitas Gadjah Mada",
    "tipe": "Bagian_Dari"
    },
    {
    "sumber": "Layanan Konsultasi Fakultas Ekonomika dan Bisnis",
    "target": "Layanan Kesehatan Mental Universitas Gadjah Mada",
    "tipe": "Bagian_Dari"
    },
]
}
"""
\end{lstlisting}


\subsection{Prompt untuk Ekstraksi Entitas dan Klasifikasi Kueri}
\begin{lstlisting}[numbers=none]
"""
Tugas: Klasifikasikan kueri pengguna ke dalam kategori 'entity_query' atau 'path_query', dan ekstrak semua entitas yang relevan.

Definisi:
'entity_query' (Query Atribut/Node): Pertanyaan yang fokus untuk mendeskripsikan atau mengambil properti/atribut dari sebuah konsep sentral. Contoh: "Apa itu X?", "Apa saja gejala dari X?".
'path_query' (Query Relasi/Edge): Pertanyaan tentang hubungan antara dua atau lebih entitas, atau mencari alur/proses. Contoh: "Bagaimana hubungan A dan B?", "Cari A yang terkait dengan B?".

Output Format (JSON):
{{
"category": "entity_query" | "path_query",
"entities": ["Entity 1", "Entity 2", ..., "Entity N"]
}}

Contoh:

Query: "Apa itu depresi dan bagaimana gejalanya?"
Output: {{"category": "entity_query", "entities": ["depresi"]}}

Query: "Apa saja jenis obat antidepresan yang umum diresepkan?"
Output: {{"category": "entity_query", "entities": ["obat antidepresan"]}}

Query: "Bagaimana cara kerja terapi kognitif-perilaku (CBT) untuk kecemasan?"
Output: {{"category": "path_query", "entities": ["terapi kognitif-perilaku (CBT)", "kecemasan"]}}

Query: "Jelaskan peran serotonin dalam gangguan mood."
Output: {{"category": "path_query", "entities": ["serotonin", "gangguan mood"]}}

Query: "Bisakah olahraga membantu mengurangi stres dan meningkatkan kesehatan mental?"
Output: {{"category": "path_query", "entities": ["olahraga", "stres", "kesehatan mental"]}}

Query: "Layanan dukungan kesehatan mental apa saja yang tersedia untuk remaja di Jakarta?"
Output: {{"category": "path_query", "entities": ["layanan dukungan kesehatan mental", "remaja", "Jakarta"]}}

Query: "Siapa psikolog yang spesialisasi di terapi trauma?"
Output: {{"category": "path_query", "entities": ["psikolog", "terapi trauma"]}}

---
Klasifikasikan dan ekstrak entitas untuk kueri berikut:

Query:
{query}
"""
\end{lstlisting}


\subsection{Prompt untuk Membuat Dataset Evaluasi}
\begin{lstlisting}[numbers=none]

	"""
Anda adalah seorang ahli pembuatan data, ditugaskan untuk membuat dataset evaluasi "Silver Standard" untuk chatbot kesehatan mental.
Respons Anda HARUS berupa daftar kamus (list of dictionaries) dalam format JSON yang valid. Jangan tambahkan teks pengantar atau penjelasan di luar struktur JSON.

**KONTEKS & ATURAN:**
1.  **Sumber Kebenaran:** Anda HANYA boleh menggunakan informasi yang disediakan di bagian 'KONTEKS DOKUMEN' dan 'NODE KNOWLEDGE GRAPH' di bawah ini. Jangan gunakan pengetahuan eksternal.
2.  **Node Knowledge Graph:** Bagian 'NODE KNOWLEDGE GRAPH' menyediakan daftar node yang tersedia beserta nama dan deskripsinya. Untuk 'golden_nodes', Anda HANYA boleh menggunakan 'name' dari node-node tersebut. Gunakan 'description' untuk memahami arti setiap node dan membuat pilihan yang lebih baik.
3.  **Tugas:** Hasilkan minimal {minimum} atau lebih contoh evaluasi yang beragam dalam format JSON yang ditentukan.
4.  **Keragaman Query:** Buat campuran `entity_query` (apa itu X?) dan `path_query` (bagaimana/mengapa X terkait dengan Y?).
5.  **Gaya Kueri:** 'query' harus mencerminkan pertanyaan pengguna yang ingin mengetahui tentang suatu hal. Buatlah sealami mungkin.
5.  **Gaya Jawaban:** 'golden_answer' harus empatik, aman, dan sangat berdasarkan pada KONTEKS yang disediakan. Jawaban tidak boleh memberikan nasihat medis.

---
**KONTEKS DOKUMEN:**
{doc}
---
**NODE KNOWLEDGE GRAPH:**
{nodes_str}
---

**CONTOH FEW-SHOT (Ikuti format dan gaya ini):**
{few_shot_examples}
---

**TUGAS ANDA:**
Sekarang, hasilkan minimal {minimum} contoh baru yang unik berdasarkan semua aturan dan konteks yang diberikan. Pastikan output Anda adalah sebuah list JSON tunggal.
"""
\end{lstlisting}

\vspace{18cm}
\section{Contoh Response}
Beriku merupakan contoh response untuk kueri \textit{"Apa itu Gangguan Mental Emosional?"}:

\begin{lstlisting}[numbers=none, language=json]
{
"message": "Sucessfull",
"data": {
  "latency": 5.0608,
  "graph_traversal": "neighbor_expansion",
  "query_class": {
    "category": "entity_query",
    "entities": [
      "Gangguan Mental Emosional"
      ]
  },
  "answer": "Gangguan Mental Emosional (GME) adalah suatu kondisi yang mengindikasikan seseorang mengalami perubahan psikologis. Perubahan ini bisa merupakan kondisi normal, namun dapat juga merupakan kondisi patologis.\n\nPenting untuk diketahui bahwa Gangguan Mental Emosional **bukanlah diagnosis gangguan jiwa**. Meskipun demikian, kondisi ini merupakan masalah kesehatan jiwa yang banyak dijumpai di Indonesia, diperkirakan diderita oleh 19 juta orang.\n\nGME dapat memengaruhi aktivitas sehari-hari seseorang, yang pada akhirnya berdampak pada menurunnya produktivitas dan kualitas hidup. Istilah ini juga digunakan dalam \"Petunjuk Teknis Pencegahan dan Pengendalian Gangguan Mental Emosional\" sebagai subjek utama panduan tersebut.",
  "knowledge": "Berikut adalah informasi yang ditemukan dari knowledge graph:
		### Entitas: Gangguan Mental Emosional (Tipe: ['Entity', 'Gangguan_Mental'])
		- Deskripsi: Bukan diagnosis gangguan jiwa. Dapat memengaruhi aktifitas sehari-hari yang berdampak pada menurunnya produktifitas dan kualitas hidup. Kondisi atau gangguan yang menjadi subjek utama dari 'Petunjuk Teknis Pencegahan dan Pengendalian Gangguan Mental Emosional'. Masalah kesehatan jiwa yang banyak dijumpai di Indonesia, diperkirakan diderita oleh 19 juta orang. Masalah kesehatan jiwa yang banyak terjadi di masyarakat. Suatu kondisi yang mengindikasikan seseorang mengalami perubahan psikologis yang mungkin merupakan sebuah kondisi normal, tetapi dapat juga merupakan kondisi patologis.
		- Skor Relevansi Awal: 5.07
		- Hubungan Terkait:
			- [OUTGOING] --[merupakan|Tipe: Adalah_Jenis_Dari]--> Masalah Kesehatan Jiwa (Tipe: ['Entity', 'Gangguan_Mental'] | Deskripsi: "Kondisi yang dapat dicegah melalui upaya promotif dan preventif.")
			- [OUTGOING] --[merupakan|Tipe: Adalah_Jenis_Dari]--> Masalah Kesehatan Jiwa (Tipe: ['Entity', 'Konsep_Abstrak'] | Deskripsi: "Istilah umum untuk kondisi yang mencakup tekanan emosional atau gangguan mental emosional. Kondisi kesehatan jiwa umum yang mencakup gangguan mental emosional.")
				- [OUTGOING] --[bukanlah diagnosis|Tipe: Adalah_Jenis_Dari]--> Gangguan Jiwa (Tipe: ['Entity', 'Gangguan_Mental'] | Deskripsi: "Berbagai macam gangguan dengan gejala yang berbeda-beda, memiliki karakteristik kombinasi pikiran yang abnormal, emosi, persepsi, perilaku dan hubungan dengan orang lain. Kondisi kesehatan mental yang menjadi objek analisa epidemiologi. Kondisi yang berbeda dengan gangguan mental emosional, dan perlu dicegah terjadinya. Kondisi yang dapat dicegah dengan deteksi dan intervensi dini gangguan mental emosional.")
				- [OUTGOING] --[dapat merupakan|Tipe: Adalah_Jenis_Dari]--> Kondisi Patologis (Tipe: ['Entity', 'Kondisi_Medis_Terkait'] | Deskripsi: "Kondisi yang mungkin terjadi pada seseorang yang mengalami perubahan psikologis.")
				- [INCOMING] <--[mencegah|Tipe: Mengurangi_Risiko]-- Upaya Promosi Kesehatan (Tipe: ['Entity', 'Aktivitas_Kesejahteraan'] | Deskripsi: "Kegiatan terintegrasi untuk mencegah dan mengendalikan GME, termasuk promosi kesehatan sesuai alur layanan GME dan promosi kesehatan yang lebih luas. Upaya yang diperlukan untuk mencegah gangguan mental emosional.")
				- ...

		### Entitas: Deteksi Gangguan Mental Emosional (Tipe: ['Entity', 'Layanan_Kesehatan'])
		- Deskripsi: Proses identifikasi gangguan mental emosional yang diharapkan mampu dilakukan oleh fasilitas pelayanan kesehatan primer.
		- Skor Relevansi Awal: 4.52
		- Hubungan Terkait:
			- [INCOMING] <--[mengurangi|Tipe: Mengurangi_Risiko]-- Keluhan fisik (Tipe: ['Entity', 'Gejala'] | Deskripsi: "Jenis keluhan yang sering dibawa penderita gangguan mental emosional ke fasilitas pelayanan kesehatan, menyebabkan ketidakdeteksian kondisi.")
			- [INCOMING] <--[mampu melakukan|Tipe: Menawarkan_Layanan]-- Fasilitas pelayanan kesehatan primer (Tipe: ['Entity', 'Penyedia_Layanan'] | Deskripsi: "Lini terdepan yang diharapkan mampu melakukan deteksi gangguan mental emosional dan intervensi dini.")
			- [OUTGOING] --[dapat segera diintervensi|Tipe: Direkomendasikan_Untuk]--> Intervensi (Tipe: ['Entity', 'Layanan_Kesehatan'] | Deskripsi: "Tindakan yang dapat dilakukan segera setelah deteksi gangguan mental emosional untuk mencegah terjadinya gangguan jiwa.")

		### Entitas: Penderita Gangguan Mental Emosional (Tipe: ['Entity', 'Individu'])
		- Deskripsi: Sebagian besar individu yang mengalami gangguan mental emosional, sering datang ke fasilitas pelayanan kesehatan dengan keluhan fisik dan tidak terdeteksi.
		- Skor Relevansi Awal: 4.52
		- Hubungan Terkait:
			- [OUTGOING] --[datang ke|Tipe: Terkait_Dengan]--> Fasilitas pelayanan kesehatan (Tipe: ['Entity', 'Penyedia_Layanan'] | Deskripsi: "Tempat penderita gangguan mental emosional sering datang dengan keluhan-keluhan fisik sehingga tidak terdeteksi.")
			- [OUTGOING] --[dengan|Tipe: Memiliki_Atribut]--> Keluhan fisik (Tipe: ['Entity', 'Gejala'] | Deskripsi: "Jenis keluhan yang sering dibawa penderita gangguan mental emosional ke fasilitas pelayanan kesehatan, menyebabkan ketidakdeteksian kondisi.")"
  "graph": [
		{
			"central_id": "070d75c6-3ae8-41d1-a4ca-c2c09ffab9a5",
			"central_name": "Gangguan Mental Emosional",
			"central_type": [
				"Entity",
				"Gangguan_Mental"
				],
			"central_description": "Bukan diagnosis gangguan jiwa. Dapat memengaruhi aktifitas sehari-hari yang berdampak pada menurunnya produktifitas dan kualitas hidup. Kondisi atau gangguan yang menjadi subjek utama dari 'Petunjuk Teknis Pencegahan dan Pengendalian Gangguan Mental Emosional'. Masalah kesehatan jiwa yang banyak dijumpai di Indonesia, diperkirakan diderita oleh 19 juta orang. Masalah kesehatan jiwa yang banyak terjadi di masyarakat. Suatu kondisi yang mengindikasikan seseorang mengalami perubahan psikologis yang mungkin merupakan sebuah kondisi normal, tetapi dapat juga merupakan kondisi patologis.",
			"score": 5.068589210510254,
			"neighborhood": [
				{
					"relation": {
						"direction": "OUTGOING",
						"name": "merupakan",
						"type": "Adalah_Jenis_Dari"
					},
					"neighbor": {
						"id": "0271758d-dd70-4cbe-bc5f-f12acdebf6dc",
						"description": "Kondisi yang dapat dicegah melalui upaya promotif dan preventif.",
						"name": "Masalah Kesehatan Jiwa",
						"type": [
							"Entity",
							"Gangguan_Mental"
							]
						}
					},
					{
					"relation": {
						"direction": "OUTGOING",
						"name": "merupakan",
						"type": "Adalah_Jenis_Dari"
					},
					"neighbor": {
						"id": "de2a5ef9-e0a8-4692-8773-2979257c826b",
						"description": "Istilah umum untuk kondisi yang mencakup tekanan emosional atau gangguan mental emosional. Kondisi kesehatan jiwa umum yang mencakup gangguan mental emosional.",
						"name": "Masalah Kesehatan Jiwa",
						"type": [
							"Entity",
							"Konsep_Abstrak"
							]
						}
					}, ...
			]
		}, ...
	]
}
}
\end{lstlisting}

\vspace{15cm}
\section{Kode}
Repositori kode dapat diakses pada \href{https://github.com/gigahidjrikaaa/UGM-AICare.git}{https://github.com/gigahidjrikaaa/UGM-AICare.git}.
\subsection{Fungsi Ekstraksi Entitas dan Relasi dari Dokumen}
\begin{lstlisting}[numbers=none, language=python]
from fastapi import APIRouter, HTTPException, Depends, Body
from pydantic import BaseModel
from datetime import datetime
import logging
import time
import asyncio
import os

from src.service.data__ingestion import DataIngestion
from src.service.llm import LLMService
from src.service.graph import GraphService
from src.service.vector_db_service import VectorDBService, Document
from src.model.schema import EntityRelationResponse, Entity, Relation
from src.utils.extraction import remove_duplicates_by_keys, resolve_entities_with_merged_descriptions, remap_relations


router = APIRouter()
logger = logging.getLogger(__name__)
async def get_data_ingestion_service():
  return DataIngestion()

async def get_llm_service():
  return LLMService()

async def get_graph_service():
  return GraphService(llm_service = await get_llm_service())

async def get_vector_service():
  return VectorDBService(llm_service = await get_llm_service())

class ExtractEntitiesBody(BaseModel):
  file_path: str
  file_type: str
  split: bool = True

@router.post("/extract")
async def extract_entities_relations(
  body: ExtractEntitiesBody = Body(...),
  data_ingestion_service: DataIngestion = Depends(get_data_ingestion_service),
  llm_service: LLMService = Depends(get_llm_service),
  graph_service: GraphService = Depends(get_graph_service)
):
  """Extract entities from text"""
  start_time = time.time()

  try:
    file_path = body.file_path
    file_type = body.file_type
    split = body.split
    logger.info(f"{file_path}, {file_type}")
    logger.info("Entity  Relation Extraction Started")

    texts = data_ingestion_service.extract_text_from_files(file_path=file_path, type=file_type, split=split)



    chunk_data = []
    for index, text in enumerate(texts):
        file_base = os.path.splitext(os.path.basename(file_path))[0]
        file_name = f"{file_base}_{datetime.now().strftime('%Y%m%d_%H%M%S')}_chunk{index+1}.txt"

        with open(f"./data/{file_name}", "w") as f:
            f.write(text)

        chunk_data.append((text, file_name))

    extraction_tasks = [llm_service.extract_entities_and_relations(text=text, chunk_id=file_name) for text, file_name in chunk_data]
    chunk_results: list[EntityRelationResponse] = await asyncio.gather(*extraction_tasks, return_exceptions=True)
    
    all_results = EntityRelationResponse(entities=[], relations=[])
    
    for res in chunk_results:
      if isinstance(res, Exception):
        logger.error(f"An error occurred during chunk extraction: {res}")
        continue
      if res:
        all_results.entities.extend(res.entities)
        all_results.relations.extend(res.relations)
  
    deduped_entities, entity_map = resolve_entities_with_merged_descriptions(entities=all_results.entities)
    remapped_relations = remap_relations(relations=all_results.relations, entity_name_map=entity_map)
    deduped_relations: list[Relation] = remove_duplicates_by_keys(remapped_relations, keys=["source_entity", "target_entity", "name", "type"])

    logger.info(f"Extracted {len(deduped_entities)} entities and {len(deduped_relations)} relations.")

    source_embedding = [
       f'{entity.name}, {entity.type}, {entity.description}'
       for entity in deduped_entities
       ]
    
    embeddings = await llm_service.get_embeddings(input=source_embedding, task="RETRIEVAL_DOCUMENT")

    for entity, embedding in zip(deduped_entities, embeddings):
      entity.embedding = embedding

    insert_entity = await graph_service.insert_entities(entities=deduped_entities)
    insert_relation = await graph_service.insert_relations(relations=deduped_relations)

    processing_time = time.time() - start_time
    return {
      "message": "successful",
      "processing_time": processing_time,
      "duplicate_entity": len(entity_map) - len(deduped_entities),
      "total_entities": len(deduped_entities),
      "total_relation": len(deduped_relations),
      "data": {
        "entities": deduped_entities,
        "relations": deduped_relations
        }
        }

  except Exception as e:
    logger.error(f"Fail to Extract Entities and Relations from Documen {body.file_path} : {str(e)}")
    raise HTTPException(status_code=500, detail=str(e))

class RAGExtractBody(BaseModel):
  file_path: str
  file_type: str
  chunk_size: int = 1000
  chunk_overlap: int = 200

class AddDocumentsResponse(BaseModel):
    success: bool
    message: str
    chunks_added: int
    documents_processed: int



@router.post("/extract-rag-vector")
async def add_document(
  body: RAGExtractBody = Body(...),
  data_ingestion_service: DataIngestion = Depends(get_data_ingestion_service),
  vector_service: VectorDBService = Depends(get_vector_service)
):
  try:

    file_path     = body.file_path
    file_type     = body.file_type
    chunk_size    = body.chunk_size
    chunk_overlap = body.chunk_overlap
    logger.info(f"{file_path}, {file_type}")
    logger.info("Add Document to Vector DB Started")

    input_docs = data_ingestion_service.extract_text_from_files(file_path=file_path, type=file_type, split=False)
    metadata = {
      "file_name": file_path
    }

    documents = []
    for doc_input in input_docs:
      doc = Document(
        content=doc_input,
        metadata=metadata,
        doc_id=file_path
        )
      documents.append(doc)
        
    result = await vector_service.add_documents(documents)
        
    return AddDocumentsResponse(**result)
  except Exception as e:
    logger.error(f"Fail to add document to RAG database: {e}")
    raise HTTPException(status_code=500, detail=str(e))
\end{lstlisting}
\subsection{Fungsi Full-Text Search}
\begin{lstlisting}[numbers=none, language=python]
async def _find_by_fulltext(self, name: str, top_k: int = 5) -> list[dict]:
    try:
        query = """
        CALL db.index.fulltext.queryNodes('entityNameIndex', $name)
        YIELD node, score
        RETURN node.name AS name, node.id AS id, node.type AS type, node.description AS description, score
        ORDER BY score DESC
        LIMIT $top_k
        """
        result = await neo4j_conn.execute_query(
            query=query, 
            parameters={
                "name": name,
                "top_k": top_k
                }
        )
        logger.info(f"found {len(result)} entities using fulltext search")
        return [dict(row) for row in result] if result else []
     except Exception as e:
       logger.warning(f"Cannot find Entity by fulltext {e}")
         return []
\end{lstlisting}
\subsection{Fungsi Vector Search}
\begin{lstlisting}[numbers=none, language=python]
async def _find_by_vector(self, name: str, query: str, top_k: int = 3) -> list[dict]:
	try: 
    embedding = await self.llm_service.get_embeddings(input=[f"{name}, {query}"], task="RETRIEVAL_QUERY")
    if not embedding or not embedding[0]:
				return None

    query = """
    CALL db.index.vector.queryNodes('entityIndex', $top_k, $embedding)
    YIELD node, score
    RETURN node.name AS name, node.id AS id, node.type AS type, node.description AS description, score
    """
    result = await neo4j_conn.execute_query(
				query=query,
				parameters={
    				"embedding" : embedding[0],
    				"top_k"     : top_k
    				}
    )
    logger.info(f"found {len(result)} entities using vector search")
    return [dict(row) for row in result] if result else []
except Exception as e:
    logger.warning(f"Cannot find Entity by vector {e}")
    return []
\end{lstlisting}
\subsection{Fungsi Neighbor Expansion Graph Traversal}
\begin{lstlisting}[numbers=none, language=python]
async def NeighborExpansion(
    self,
    query: str,
    candidate_entities: list[str],
    search_method: Literal['vector', 'auto'] = 'auto',
    top_k: int = 3,
    limit: int = 50,
) -> list[dict]:
    if not isinstance(candidate_entities, list) or not candidate_entities:
        raise ValueError("candidate_entities must be a non-empty list")

    try:
        logger.info(
            f"Starting entity-based neighbor search for {len(candidate_entities)} "
            f"candidates using search method '{search_method}'"
        )

        # Entity extraction
        if search_method == 'vector':
            entities = await self.find_entity(query=query, top_k=top_k, method='vector')
        else:
            entities_nested = await asyncio.gather(*[
                self.find_entity(entity=e, query=query, top_k=top_k, method='auto')
                for e in candidate_entities
            ])
            entities = [
                item
                for sublist in entities_nested if sublist
                for item in sublist
            ]

        # Deduplicate entities
        unique_entities_map = {item['id']: item for item in entities}
        unique_entities = list(unique_entities_map.values())

        if not unique_entities:
            logger.warning("No valid entities found from candidates")
            return []

        logger.info(f"Found {len(unique_entities)} valid entities in total from candidates")

        # Cypher query
        query_cypher = """
        UNWIND $entities AS entity
        MATCH (central:Entity) 
        WHERE central.id = entity.id

        CALL (central) {
            OPTIONAL MATCH (central)-[r]-(neighbor)
            RETURN COLLECT({
                neighbor: {
                    id: neighbor.id,
                    name: neighbor.name,
                    type: labels(neighbor),
                    description: neighbor.description
                },
                relation: {
                    name: r.name,
                    type: type(r),
                    direction: CASE 
                        WHEN startNode(r).id = central.id 
                        THEN 'OUTGOING' 
                        ELSE 'INCOMING' 
                    END
                }
            })[..$neighbor_limit] AS limited_neighborhood
        }

        RETURN
            central.id AS central_id,
            central.name AS central_name,
            labels(central) AS central_type,
            central.description AS central_description,
            entity.score AS score,
            limited_neighborhood AS neighborhood
        LIMIT $limit
        """

        parameters = {
            "entities": unique_entities,
            "limit": limit,
            "neighbor_limit": 20,
        }

        # Execute query
        result = await neo4j_conn.execute_query(
            query=query_cypher,
            parameters=parameters
        )

        records = result.record if hasattr(result, "record") else result
        logger.info(
            f"Entity-based neighbor search completed, returned {len(records)} results"
        )

        return [dict(record) for record in records]

    except Exception as e:
        logger.error(f"Entity-based neighbor search failed: {e}")
        return []

\end{lstlisting}
\subsection{Fungsi N-Shortest Path Graph Traversal}
\begin{lstlisting}[numbers=none, language=python]
async def N_ShortestPath(
    self,
    query: str,
    search_method: Literal['vector', 'auto'] = 'auto',
    candidate_entities: list = [],
    max_hop: int = 10,
    paths_per_group: int = 5,
    top_k: int = 2,
) -> list[dict]:
    try:
        logger.info(
            f"Starting entity-based neighbor search for {len(candidate_entities)} candidates"
        )

        # Entity extraction
        if search_method == 'vector':
            entities = await self.find_entity(query=query, top_k=top_k, method='vector')
            entities_nested = [entities]
        else:
            entities_nested = await asyncio.gather(*[
                self.find_entity(entity=e, query=query, top_k=top_k, method='auto')
                for e in candidate_entities
            ])
            if len(entities_nested) == 1:
                entities_nested = [[entity] for entity in entities_nested[0]]

            entities = [
                item
                for sublist in entities_nested if sublist
                for item in sublist
            ]

        # Deduplicate entities
        unique_entities_map = {item['id']: item for item in entities}
        unique_entities = list(unique_entities_map.values())

        if not unique_entities:
            logger.warning("No valid entities found from candidates")
            return []

        logger.info(f"Found {len(unique_entities)} valid entities in total from candidates")

        # Group entities
        entity_groups = [
            [entity['id'] for entity in group]
            for group in entities_nested
            if group
        ]

        # Cypher query for shortest paths
        query_cypher = f"""
        UNWIND range(0, size($entity_groups)-1) AS i
        UNWIND range(i+1, size($entity_groups)-1) AS j
        WITH i, j, $entity_groups[i] AS source_candidates, $entity_groups[j] AS target_candidates

        UNWIND source_candidates AS source_id
        UNWIND target_candidates AS target_id
        WITH i, j, source_id, target_id
        WHERE source_id <> target_id

        MATCH (source:Entity {{id: source_id}})
        MATCH (target:Entity {{id: target_id}})
        MATCH p = allShortestPaths((source)-[*1..{max_hop}]-(target))
        WHERE ALL(n IN nodes(p) WHERE n.id IS NOT NULL)

        WITH i AS source_group_index, 
             p, source, target, 
             nodes(p) AS path_nodes_raw, 
             relationships(p) AS path_rels_raw,
             length(p) AS hops

        WITH source_group_index, 
             collect({{
                 p: p,
                 source: source,
                 target: target,
                 path_nodes_raw: path_nodes_raw,
                 path_rels_raw: path_rels_raw,
                 hops: hops
             }}) AS group_paths

        WITH source_group_index,
             [path IN group_paths | path][0..coalesce($paths_per_group, 10)] AS limited_paths

        UNWIND limited_paths AS path_data

        RETURN DISTINCT
            path_data.source.id AS source_id,
            path_data.target.id AS target_id,
            source_group_index,
            [i IN range(0, size(path_data.path_nodes_raw)-1) | {{
                id: path_data.path_nodes_raw[i].id,
                name: path_data.path_nodes_raw[i].name,
                type: path_data.path_nodes_raw[i].type,
                description: path_data.path_nodes_raw[i].description,
                position: i
            }}] AS path_nodes,
            [i IN range(0, size(path_data.path_rels_raw)-1) | {{
                type: type(path_data.path_rels_raw[i]),
                name: path_data.path_rels_raw[i].name,
                direction: CASE 
                    WHEN startNode(path_data.path_rels_raw[i]).id = path_data.path_nodes_raw[i].id 
                    THEN 'OUTGOING' 
                    ELSE 'INCOMING' 
                END
            }}] AS path_rels,
            path_data.hops AS hops
        ORDER BY source_group_index, path_data.hops ASC
        """

        # Execute query
        result = await neo4j_conn.execute_query(
            query=query_cypher,
            parameters={
                "entity_groups": entity_groups,
                "paths_per_group": paths_per_group,
            }
        )

        records = result.record if hasattr(result, "record") else result
        return [dict(record) for record in records]

    except Exception as e:
        logger.error(f"Entity Based All Shortest Path search failed: {e}")
        return []
\end{lstlisting}